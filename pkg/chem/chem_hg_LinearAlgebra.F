C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C                                                                  
C Linear Algebra Data and Routines File                            
C                                                                  
C Generated by KPP-2.2.3 symbolic chemistry Kinetics PreProcessor  
C       (http://www.cs.vt.edu/~asandu/Software/KPP)                
C KPP is distributed under GPL, the general public licence         
C       (http://www.gnu.org/copyleft/gpl.html)                     
C (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa           
C (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech            
C     With important contributions from:                           
C        M. Damian, Villanova University, USA                      
C        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany
C                                                                  
C File                 : chem_hg_LinearAlgebra.f                   
C Time                 : Thu Mar 27 11:36:36 2014                  
C Working directory    : /n/home05/yxzhang/kpp/kpp-2.2.3/mehg      
C Equation file        : chem_hg.kpp                               
C Output root filename : chem_hg                                   
C                                                                  
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C                                                                  
C SPARSE_UTIL - SPARSE utility functions                           
C   Arguments :                                                    
C                                                                  
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE KppDecomp( JVS, IER )
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C        Sparse LU factorization
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      INCLUDE 'chem_hg_Parameters.h'
      INCLUDE 'chem_hg_Sparse.h'

      INTEGER  IER
      REAL*8 JVS(31), W(14)
      INTEGER  k, kk, j, jj
      REAL*8 a 

      IER = 0
      DO k=1,NVAR
        IF ( JVS( LU_DIAG(k) ) .EQ. 0. ) THEN
            IER = k
            RETURN
        END IF
        DO kk = LU_CROW(k), LU_CROW(k+1)-1
              W( LU_ICOL(kk) ) = JVS(kk)
        END DO
        DO kk = LU_CROW(k), LU_DIAG(k)-1
            j = LU_ICOL(kk)
            a = -W(j) / JVS( LU_DIAG(j) )
            W(j) = -a
            DO jj = LU_DIAG(j)+1, LU_CROW(j+1)-1
               W( LU_ICOL(jj) ) = W( LU_ICOL(jj) ) + a*JVS(jj)
            END DO
         END DO
         DO kk = LU_CROW(k), LU_CROW(k+1)-1
            JVS(kk) = W( LU_ICOL(kk) )
         END DO
      END DO
      RETURN
      END

C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE KppDecompCmplx( JVS, IER )
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C        Sparse LU factorization, complex
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      INCLUDE 'chem_hg_Parameters.h'
      INCLUDE 'chem_hg_Sparse.h'

      INTEGER  IER
      DOUBLE COMPLEX JVS(31), W(14), a
      INTEGER  k, kk, j, jj

      IER = 0
      DO k=1,NVAR
        IF ( JVS( LU_DIAG(k) ) .EQ. 0. ) THEN
            IER = k
            RETURN
        END IF
        DO kk = LU_CROW(k), LU_CROW(k+1)-1
              W( LU_ICOL(kk) ) = JVS(kk)
        END DO
        DO kk = LU_CROW(k), LU_DIAG(k)-1
            j = LU_ICOL(kk)
            a = -W(j) / JVS( LU_DIAG(j) )
            W(j) = -a
            DO jj = LU_DIAG(j)+1, LU_CROW(j+1)-1
               W( LU_ICOL(jj) ) = W( LU_ICOL(jj) ) + a*JVS(jj)
            END DO
         END DO
         DO kk = LU_CROW(k), LU_CROW(k+1)-1
            JVS(kk) = W( LU_ICOL(kk) )
         END DO
      END DO
      RETURN
      END

C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE KppSolveIndirect( JVS, X )
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C        Sparse solve subroutine using indirect addressing
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INCLUDE 'chem_hg_Parameters.h'
      INCLUDE 'chem_hg_Sparse.h'

      INTEGER i, j
      REAL*8 JVS(31), X(14), sum

      DO i=1,NVAR
         DO j = LU_CROW(i), LU_DIAG(i)-1 
             X(i) = X(i) - JVS(j)*X(LU_ICOL(j));
	 END DO  
      END DO

      DO i=NVAR,1,-1
        sum = X(i);
        DO j = LU_DIAG(i)+1, LU_CROW(i+1)-1
          sum = sum - JVS(j)*X(LU_ICOL(j));
	END DO
        X(i) = sum/JVS(LU_DIAG(i));
      END DO
      
      RETURN
      END

C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      SUBROUTINE KppSolveCmplx( JVS, X )
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C        Complex sparse solve subroutine using indirect addressing
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      INCLUDE 'chem_hg_Parameters.h'
      INCLUDE 'chem_hg_Sparse.h'

      INTEGER i, j
      DOUBLE COMPLEX JVS(31), X(14), sum

      DO i=1,NVAR
         DO j = LU_CROW(i), LU_DIAG(i)-1 
             X(i) = X(i) - JVS(j)*X(LU_ICOL(j));
	 END DO  
      END DO

      DO i=NVAR,1,-1
        sum = X(i);
        DO j = LU_DIAG(i)+1, LU_CROW(i+1)-1
          sum = sum - JVS(j)*X(LU_ICOL(j));
	END DO
        X(i) = sum/JVS(LU_DIAG(i));
      END DO
      
      RETURN
      END
C End of SPARSE_UTIL function                                      
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C                                                                  
C KppSolve - sparse back substitution                              
C   Arguments :                                                    
C      JVS       - sparse Jacobian of variables                    
C      X         - Vector for variables                            
C                                                                  
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      SUBROUTINE KppSolve ( JVS, X )

      IMPLICIT NONE
      INCLUDE 'chem_hg_Parameters.h'

C JVS - sparse Jacobian of variables                               
      REAL*8 JVS(LU_NONZERO)
C X - Vector for variables                                         
      REAL*8 X(NVAR)

      X(12) = X(12)-JVS(23)*X(11)
      X(13) = X(13)-JVS(26)*X(12)
      X(14) = X(14)-JVS(29)*X(12)-JVS(30)*X(13)
      X(14) = X(14)/JVS(31)
      X(13) = (X(13)-JVS(28)*X(14))/(JVS(27))
      X(12) = (X(12)-JVS(25)*X(14))/(JVS(24))
      X(11) = (X(11)-JVS(22)*X(12))/(JVS(21))
      X(10) = (X(10)-JVS(20)*X(11))/(JVS(19))
      X(9) = (X(9)-JVS(18)*X(12))/(JVS(17))
      X(8) = (X(8)-JVS(16)*X(12))/(JVS(15))
      X(7) = (X(7)-JVS(14)*X(12))/(JVS(13))
      X(6) = (X(6)-JVS(12)*X(14))/(JVS(11))
      X(5) = (X(5)-JVS(10)*X(13))/(JVS(9))
      X(4) = (X(4)-JVS(8)*X(14))/(JVS(7))
      X(3) = (X(3)-JVS(6)*X(14))/(JVS(5))
      X(2) = (X(2)-JVS(4)*X(13))/(JVS(3))
      X(1) = (X(1)-JVS(2)*X(13))/(JVS(1))
      RETURN
      END

C End of KppSolve function                                         
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C                                                                  
C KppSolveTR - sparse, transposed back substitution                
C   Arguments :                                                    
C      JVS       - sparse Jacobian of variables                    
C      X         - Vector for variables                            
C      XX        - Vector for output variables                     
C                                                                  
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      SUBROUTINE KppSolveTR ( JVS, X, XX )

      IMPLICIT NONE
      INCLUDE 'chem_hg_Parameters.h'

C JVS - sparse Jacobian of variables                               
      REAL*8 JVS(LU_NONZERO)
C X - Vector for variables                                         
      REAL*8 X(NVAR)
C XX - Vector for output variables                                 
      REAL*8 XX(NVAR)

      XX(1) = X(1)/JVS(1)
      XX(2) = X(2)/JVS(3)
      XX(3) = X(3)/JVS(5)
      XX(4) = X(4)/JVS(7)
      XX(5) = X(5)/JVS(9)
      XX(6) = X(6)/JVS(11)
      XX(7) = X(7)/JVS(13)
      XX(8) = X(8)/JVS(15)
      XX(9) = X(9)/JVS(17)
      XX(10) = X(10)/JVS(19)
      XX(11) = (X(11)-JVS(20)*XX(10))/(JVS(21))
      XX(12) = (X(12)-JVS(14)*XX(7)-JVS(16)*XX(8)-JVS(18)*XX(9)
     &        -JVS(22)*XX(11))/(JVS(24))
      XX(13) = (X(13)-JVS(2)*XX(1)-JVS(4)*XX(2)-JVS(10)*XX(5))
     &        /(JVS(27))
      XX(14) = (X(14)-JVS(6)*XX(3)-JVS(8)*XX(4)-JVS(12)*XX(6)-JVS(25)
     &        *XX(12)-JVS(28)*XX(13))/(JVS(31))
      XX(14) = XX(14)
      XX(13) = XX(13)-JVS(30)*XX(14)
      XX(12) = XX(12)-JVS(26)*XX(13)-JVS(29)*XX(14)
      XX(11) = XX(11)-JVS(23)*XX(12)
      XX(10) = XX(10)
      XX(9) = XX(9)
      XX(8) = XX(8)
      XX(7) = XX(7)
      XX(6) = XX(6)
      XX(5) = XX(5)
      XX(4) = XX(4)
      XX(3) = XX(3)
      XX(2) = XX(2)
      XX(1) = XX(1)
      RETURN
      END

C End of KppSolveTR function                                       
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C                                                                  
C BLAS_UTIL - BLAS-LIKE utility functions                          
C   Arguments :                                                    
C                                                                  
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!--------------------------------------------------------------
!
! BLAS/LAPACK-like subroutines used by the integration algorithms
! It is recommended to replace them by calls to the optimized
!      BLAS/LAPACK library for your machine
!
!  (C) Adrian Sandu, Aug. 2004
!      Virginia Polytechnic Institute and State University
!--------------------------------------------------------------


!--------------------------------------------------------------
      SUBROUTINE  WCOPY(N,X,incX,Y,incY)
!--------------------------------------------------------------
!     copies a vector, x, to a vector, y:  y <- x
!     only for incX=incY=1
!     after BLAS
!     replace this by the function from the optimized BLAS implementation:
!         CALL  SCOPY(N,X,1,Y,1)   or   CALL  DCOPY(N,X,1,Y,1)
!--------------------------------------------------------------
      
      INTEGER i,incX,incY,M,MP1,N
      REAL*8 X(N),Y(N)

      IF (N.LE.0) RETURN

      M = MOD(N,8)
      IF( M .NE. 0 ) THEN
        DO i = 1,M
          Y(i) = X(i)
        END DO
        IF( N .LT. 8 ) RETURN
      END IF	
      MP1 = M+1
      DO i = MP1,N,8
        Y(i) = X(i)
        Y(i + 1) = X(i + 1)
        Y(i + 2) = X(i + 2)
        Y(i + 3) = X(i + 3)
        Y(i + 4) = X(i + 4)
        Y(i + 5) = X(i + 5)
        Y(i + 6) = X(i + 6)
        Y(i + 7) = X(i + 7)
      END DO
      RETURN
      END


!--------------------------------------------------------------
      SUBROUTINE WAXPY(N,Alpha,X,incX,Y,incY)
!--------------------------------------------------------------
!     constant times a vector plus a vector: y <- y + Alpha*x
!     only for incX=incY=1
!     after BLAS
!     replace this by the function from the optimized BLAS implementation:
!         CALL SAXPY(N,Alpha,X,1,Y,1) or  CALL DAXPY(N,Alpha,X,1,Y,1)
!--------------------------------------------------------------

      INTEGER i,incX,incY,M,MP1,N
      REAL*8 X(N),Y(N),Alpha
      REAL*8 ZERO
      PARAMETER( ZERO = 0.0d0 )

      IF (Alpha .EQ. ZERO) RETURN
      IF (N .LE. 0) RETURN

      M = MOD(N,4)
      IF( M .NE. 0 ) THEN
        DO i = 1,M
          Y(i) = Y(i) + Alpha*X(i)
        END DO
        IF( N .LT. 4 ) RETURN
      END IF
      MP1 = M + 1
      DO i = MP1,N,4
        Y(i) = Y(i) + Alpha*X(i)
        Y(i + 1) = Y(i + 1) + Alpha*X(i + 1)
        Y(i + 2) = Y(i + 2) + Alpha*X(i + 2)
        Y(i + 3) = Y(i + 3) + Alpha*X(i + 3)
      END DO
      RETURN
      END



!--------------------------------------------------------------
      SUBROUTINE WSCAL(N,Alpha,X,incX)
!--------------------------------------------------------------
!     constant times a vector: x(1:N) <- Alpha*x(1:N) 
!     only for incX=incY=1
!     after BLAS
!     replace this by the function from the optimized BLAS implementation:
!         CALL SSCAL(N,Alpha,X,1) or  CALL DSCAL(N,Alpha,X,1)
!--------------------------------------------------------------

      INTEGER i,incX,M,MP1,N
      REAL*8 X(N),Alpha
      REAL*8 ZERO, ONE
      PARAMETER( ZERO = 0.0d0 )
      PARAMETER( ONE  = 1.0d0 )

      IF (Alpha .EQ. ONE) RETURN
      IF (N .LE. 0) RETURN

      M = MOD(N,5)
      IF( M .NE. 0 ) THEN
        IF (Alpha .EQ. (-ONE)) THEN
          DO i = 1,M
            X(i) = -X(i)
          END DO
        ELSEIF (Alpha .EQ. ZERO) THEN
          DO i = 1,M
            X(i) = ZERO
          END DO
        ELSE
          DO i = 1,M
            X(i) = Alpha*X(i)
          END DO
        END IF
        IF( N .LT. 5 ) RETURN
      END IF
      MP1 = M + 1
      IF (Alpha .EQ. (-ONE)) THEN
        DO i = MP1,N,5
          X(i)     = -X(i)
          X(i + 1) = -X(i + 1)
          X(i + 2) = -X(i + 2)
          X(i + 3) = -X(i + 3)
          X(i + 4) = -X(i + 4)
        END DO
      ELSEIF (Alpha .EQ. ZERO) THEN
        DO i = MP1,N,5
          X(i)     = ZERO
          X(i + 1) = ZERO
          X(i + 2) = ZERO
          X(i + 3) = ZERO
          X(i + 4) = ZERO
        END DO
      ELSE
        DO i = MP1,N,5
          X(i)     = Alpha*X(i)
          X(i + 1) = Alpha*X(i + 1)
          X(i + 2) = Alpha*X(i + 2)
          X(i + 3) = Alpha*X(i + 3)
          X(i + 4) = Alpha*X(i + 4)
        END DO
      END IF
      RETURN
      END

!--------------------------------------------------------------
      REAL*8 FUNCTION WLAMCH( C )
!--------------------------------------------------------------
!     returns epsilon machine
!     after LAPACK
!     replace this by the function from the optimized LAPACK implementation:
!          CALL SLAMCH('E') or CALL DLAMCH('E')
!--------------------------------------------------------------

      CHARACTER C
      INTEGER   i
      REAL*8  ONE, HALF, Eps, Suma
      PARAMETER (ONE  = 1.0d0)
      PARAMETER (HALF = 0.5d0)
      LOGICAL   First
      SAVE     First, Eps
      DATA     First /.TRUE./
      
      IF (First) THEN
        First = .FALSE.
        Eps = HALF**(16)
        DO i = 17, 80
          Eps = Eps*HALF
	  CALL WLAMCH_ADD(ONE,Eps,Suma)
	  IF (Suma.LE.ONE) GOTO 10
        END DO
        PRINT*,'ERROR IN WLAMCH. EPS < ',Eps
        RETURN
10      Eps = Eps*2
        i = i-1      
      END IF

      WLAMCH = Eps

      RETURN
      END
     
      SUBROUTINE WLAMCH_ADD( A, B, Suma )
      REAL*8 A, B, Suma
      Suma = A + B
      RETURN
      END

!--------------------------------------------------------------
      SUBROUTINE SET2ZERO(N,Y)
!--------------------------------------------------------------
!     copies zeros into the vector y:  y <- 0
!     after BLAS
!--------------------------------------------------------------
      
      INTEGER   i,M,MP1,N
      REAL*8  Y(N)

      IF (N.LE.0) RETURN

      M = MOD(N,8)
      IF( M .NE. 0 ) THEN
        DO i = 1,M
          Y(i) = 0.0d0
        END DO
        IF( N .LT. 8 ) RETURN
      END IF    
      MP1 = M+1
      DO i = MP1,N,8
        Y(i)     = 0.0d0
        Y(i + 1) = 0.0d0
        Y(i + 2) = 0.0d0
        Y(i + 3) = 0.0d0
        Y(i + 4) = 0.0d0
        Y(i + 5) = 0.0d0
        Y(i + 6) = 0.0d0
        Y(i + 7) = 0.0d0
      END DO

      END SUBROUTINE SET2ZERO


!--------------------------------------------------------------
      REAL*8 FUNCTION WDOT (N, DX, incX, DY, incY) 
!--------------------------------------------------------------
!     dot produce: wdot = x(1:N)*y(1:N) 
!     only for incX=incY=1
!     after BLAS
!     replace this by the function from the optimized BLAS implementation:
!         CALL SDOT(N,X,1,Y,1) or  CALL DDOT(N,X,1,Y,1)
!--------------------------------------------------------------
!      USE messy_mecca_kpp_Precision
!--------------------------------------------------------------
      IMPLICIT NONE
      INTEGER  N, incX, incY
      REAL*8 DX(N), DY(N) 

      INTEGER  i, IX, IY, M, MP1, NS
                                 
      WDOT = 0.0D0 
      IF (N .LE. 0) RETURN 
      IF (incX .EQ. incY) IF (incX-1) 5,20,60 
!                                                                       
!     Code for unequal or nonpositive increments.                       
!                                                                       
    5 IX = 1 
      IY = 1 
      IF (incX .LT. 0) IX = (-N+1)*incX + 1 
      IF (incY .LT. 0) IY = (-N+1)*incY + 1 
      DO i = 1,N 
        WDOT = WDOT + DX(IX)*DY(IY) 
        IX = IX + incX 
        IY = IY + incY 
      END DO 
      RETURN 
!                                                                       
!     Code for both increments equal to 1.                              
!                                                                       
!     Clean-up loop so remaining vector length is a multiple of 5.      
!                                                                       
   20 M = MOD(N,5) 
      IF (M .EQ. 0) GO TO 40 
      DO i = 1,M 
         WDOT = WDOT + DX(i)*DY(i) 
      END DO 
      IF (N .LT. 5) RETURN 
   40 MP1 = M + 1 
      DO i = MP1,N,5 
          WDOT = WDOT + DX(i)*DY(i) 
     &            + DX(i+1)*DY(i+1) + DX(i+2)*DY(i+2) 
     &            + DX(i+3)*DY(i+3) + DX(i+4)*DY(i+4)                   
      END DO 
      RETURN 
!                                                                       
!     Code for equal, positive, non-unit increments.                    
!                                                                       
   60 NS = N*incX 
      DO i = 1,NS,incX 
        WDOT = WDOT + DX(i)*DY(i) 
      END DO 

      END FUNCTION WDOT                                          


!--------------------------------------------------------------
      SUBROUTINE WADD(N,X,Y,Z)
!--------------------------------------------------------------
!     adds two vectors: z <- x + y
!     BLAS - like
!--------------------------------------------------------------
      
      INTEGER  i, M, MP1, N
      REAL*8  X(N),Y(N),Z(N)

      IF (N.LE.0) RETURN

      M = MOD(N,5)
      IF( M .NE. 0 ) THEN
         DO i = 1,M
            Z(i) = X(i) + Y(i)
         END DO
         IF( N .LT. 5 ) RETURN
      END IF    
      MP1 = M+1
      DO i = MP1,N,5
         Z(i)     = X(i)     + Y(i)
         Z(i + 1) = X(i + 1) + Y(i + 1)
         Z(i + 2) = X(i + 2) + Y(i + 2)
         Z(i + 3) = X(i + 3) + Y(i + 3)
         Z(i + 4) = X(i + 4) + Y(i + 4)
      END DO

      END SUBROUTINE WADD
!--------------------------------------------------------------
C End of BLAS_UTIL function                                        
C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


